// ============================================================
// Export module â€” Text & Markdown with grouping preserved
// ============================================================

function groupItems(items, groupBy) {
    const groups = {};
    items.forEach(item => {
        const key = item[groupBy] || 'other';
        if (!groups[key]) groups[key] = [];
        groups[key].push(item);
    });
    return groups;
}

function formatGroupLabel(key) {
    return key.charAt(0).toUpperCase() + key.slice(1).replace(/-/g, ' ');
}

// ---- Text Export ----

export function exportAsText(spec, groupBy = 'type') {
    let output = '';

    output += `${'='.repeat(60)}\n`;
    output += `FEATURE SPECIFICATION: ${spec.featureName}\n`;
    output += `${'='.repeat(60)}\n\n`;
    output += `Created: ${new Date(spec.createdAt).toLocaleDateString()}\n`;
    output += `Template: ${spec.template || 'Custom'}\n`;
    output += `Target Users: ${spec.targetUsers}\n`;
    if (spec.constraints) output += `Constraints: ${spec.constraints}\n`;
    output += '\n';

    // Combine stories and tasks for grouping
    const allItems = [
        ...spec.stories.map(s => ({ ...s, type: 'story' })),
        ...spec.tasks.map(t => ({ ...t, type: 'task' })),
    ];

    const groups = groupItems(allItems, groupBy);

    output += `${'-'.repeat(40)}\n`;
    output += `WORK ITEMS (grouped by ${groupBy})\n`;
    output += `${'-'.repeat(40)}\n\n`;

    for (const [key, items] of Object.entries(groups)) {
        output += `[${formatGroupLabel(key)}]\n`;
        items.forEach((item, i) => {
            const prefix = item.type === 'story' ? 'ðŸ“–' : 'ðŸ”§';
            output += `  ${prefix} ${item.title}\n`;
            if (item.description) output += `     ${item.description}\n`;
        });
        output += '\n';
    }

    // Risks
    if (spec.risks && spec.risks.length > 0) {
        output += `${'-'.repeat(40)}\n`;
        output += `RISKS & UNKNOWNS\n`;
        output += `${'-'.repeat(40)}\n\n`;
        spec.risks.forEach(risk => {
            output += `  âš  [${risk.type}] ${risk.text}\n`;
        });
        output += '\n';
    }

    output += `${'='.repeat(60)}\n`;
    output += `Generated by SpecFlow\n`;

    return output;
}

// ---- Markdown Export ----

export function exportAsMarkdown(spec, groupBy = 'type') {
    let output = '';

    output += `# ${spec.featureName}\n\n`;
    output += `| Field | Value |\n`;
    output += `|-------|-------|\n`;
    output += `| **Created** | ${new Date(spec.createdAt).toLocaleDateString()} |\n`;
    output += `| **Template** | ${(spec.template || 'Custom').charAt(0).toUpperCase() + (spec.template || 'custom').slice(1)} |\n`;
    output += `| **Target Users** | ${spec.targetUsers} |\n`;
    if (spec.constraints) output += `| **Constraints** | ${spec.constraints} |\n`;
    output += '\n---\n\n';

    // Combine stories and tasks
    const allItems = [
        ...spec.stories.map(s => ({ ...s, type: 'story' })),
        ...spec.tasks.map(t => ({ ...t, type: 'task' })),
    ];

    const groups = groupItems(allItems, groupBy);

    output += `## Work Items\n\n`;
    output += `> Grouped by **${groupBy}**\n\n`;

    for (const [key, items] of Object.entries(groups)) {
        output += `### ${formatGroupLabel(key)}\n\n`;
        items.forEach(item => {
            const checkbox = '- [ ]';
            const badge = item.type === 'story' ? '`story`' : '`task`';
            const priorityBadge = item.priority ? ` \`${item.priority}\`` : '';
            output += `${checkbox} ${badge}${priorityBadge} ${item.title}\n`;
            if (item.description) output += `  > ${item.description}\n`;
        });
        output += '\n';
    }

    // Risks
    if (spec.risks && spec.risks.length > 0) {
        output += `## âš ï¸ Risks & Unknowns\n\n`;
        spec.risks.forEach(risk => {
            const icon = risk.type === 'Blocker' ? 'ðŸ”´' : risk.type === 'Unknown' ? 'ðŸŸ¡' : 'ðŸ”µ';
            output += `- ${icon} **${risk.type}**: ${risk.text}\n`;
        });
        output += '\n';
    }

    output += `---\n\n*Generated by SpecFlow*\n`;

    return output;
}

// ---- Download Helper ----

export function downloadFile(content, filename) {
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
